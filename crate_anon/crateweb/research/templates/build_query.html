{# build_query.html #}

{% extends "base.html" %}

{% block content %}

    {% include "query_nav.html" %}

    <h1>Build a simple query</h1>
    <p>For more advanced queries, see the
        <a href="{% url 'query' %}">SQL view</a>.</p>

    <h2>Current query</h2>
    {% if parse_error %}
        <div class="warning">SQL FAILED TO PARSE. Please clear the query.
            Error was: {{ parse_error }}</div>
    {% endif %}
    {% if sql %}
        <pre class="sql">{{ sql }}</pre>
        <form action="{% url 'build_query' %}" method="post">
            {% csrf_token %}
            <input type="submit" name="global_clear" value="Clear" />
            {% if not parse_error %}
                <input type="submit" name="global_toggle_distinct"
                       value="Toggle DISTINCT" />
                <input type="submit" name="global_save" value="Save as query" />
                <input type="submit" name="global_run" value="Run" />
            {% endif %}
        </form>
    {% else %}
        {# single space to show the area visually #}
        <pre class="sql"> </pre>
    {% endif %}

    {% if not parse_error %}
        <h2>Build your query!</h2>
        <p>Explore the tree below and add columns or conditions.</p>
        {% include "expand_collapse_buttons.html" %}
REPLACE_ME_BUILDER
    {% endif %}

    <h2>Tips</h2>
    <ul>
        <li>This query builder only looks at fields in the <b>data
            dictionary</b> that was used to create the research database,
            and then still only tables that are connected to patients (not
            “system” tables with no connection to a patient). If you want to
            explore all the tables, explore the database structure using the
            options on the <a href="{% url 'home' %}">Main menu</a>,
            and use the <a href="{% url 'query' %}">SQL view</a> to create
            a more complex query.</li>

        <li>This query builder parses the SQL you start with, and then
            adds more pieces. It is less powerful than arbitrary SQL.</li>

        <li>Inexact string comparison can be done in several ways:
            <ul>
                <li><a href="http://dev.mysql.com/doc/refman/5.7/en/pattern-matching.html">LIKE</a>,
                    in which ‘%’ stands for any number of characters, and ‘_’
                    for one unknown character. For example, use
                    <span class="code">%schizophreni%</span> to find text
                    containing ‘schizophrenia’, ‘schizophrenic’, or
                    ‘schizophreniform’.</li>
                <li><a href="https://dev.mysql.com/doc/refman/5.7/en/fulltext-search.html">MATCH</a>,
                    which is much faster than LIKE. MATCH can be used if there
                    is a full-text index on the column in question. You can
                    MATCH AGAINST words or phrases.</li>
                <li><a href="http://dev.mysql.com/doc/refman/5.7/en/pattern-matching.html">REGEXP</a>,
                    using <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>.
                    This is complicated; see a <a href="http://regexone.com/">tutorial</a>
                    and use a <a href="http://regexr.com/">regular expression tester</a>.</li>
            </ul></li>


        <li>
            The things that are are better done with raw SQL include:
            <ul>
                <li>Combining expressions with OR, or in complex ways.</li>
                <li>Restricting to a set of values with IN.</li>
                <li>Finding information about patients P that “have” something
                    (e.g. a diagnosis) using EXISTS.</li>
            </ul>
        </li>

        <li>If you use a file (for IN or NOT IN clauses), this file should be
            in ASCII or UTF-8 format, with one value per line. Lines will
            be stripped of whitespace (left + right).</li>
    </ul>

{% endblock %}
